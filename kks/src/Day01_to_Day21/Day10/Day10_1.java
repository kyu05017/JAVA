package Day01_to_Day21.Day10;

public class Day10_1 {
	// p.338
		// 1. 1) 다중상속을 허용하지 않는다.
		// 2. 2) 항상은 강제형변환이 안된다.
			// 4) instanceof = 부모를 확인 
		// 3. 1) final 클래스는 부모클래스로 사용할수 없다
		// 4. 4) protected 접근 제한을 갖는 메소드는 다른 패키지의 자식클래스를 정의할수 있다.
			// @ = 어노테이션
		// 5) 부모클래스와 자식클래스 간 생성자 동일
			// 1. this.name = name > super(name);
			// 2. 부모클래스 내에 빈 생상자 생성
	
		// 6. 자식클래스가 메모리할당 [ 객체 생성 ]을 하면 부모 클래스내 생성자 호출 우선
			// this.필드명 : 현클래스 내 필드 호출
			// this.메소드명() : 현클래스 내 메소드 호출
			// this() : 현클래스 내 생성자 호출
			// super.필드명 : 부모클래스 내 필드 호출
			// super.메소드명() : 부모클래스 내 메소드 호출
			// super() : 부모클래스 내 생성자 호출
			// 1. 자식클래스 기본생성자 호출 > 마지막 출력
			// 2. 부모클래스 기본생성자 호출1 > 2번 출력
			// 3. 부모클래스내 [1개 인수] 생성자 호출 > 1번 출력
			// 4. 자식클래스내 [1개 인수] 생성자 호출 > 3번 출력
	
		// 7. 
			// 자식클래스 객체명 = new 자식생성자();
			// 부모클래스 객체명 = 자식객체명; > 다형성
				// 1. 스노우 타이어가 굴러갑니다. > 자식객체명.run()
					// 오버라이드 했기 때문에
				// 2. 스노우 타이어가 굴러갑니다. > 부모클래스.run()
					// 자식이 부모로 타입변환 했기 때문에
	
		// 8. 
			// 2 : 강제 형변환 가능하나 .... 문법이 틀림
				// new 앞에 강제 형변환 불가능
					// (B) new (A) [x] > 
					// A a = new A();
					// B b = (B) a;
	public static void main(String[] args) {
		Child child = new Child();
	}
	
}
